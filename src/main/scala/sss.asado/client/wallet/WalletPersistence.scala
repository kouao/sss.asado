package sss.asado.client.wallet

import ledger._
import org.joda.time.DateTime
import sss.ancillary.Logging
import sss.asado.util.ByteArrayVarcharOps._
import sss.db.{Db, Row, Where}
import scala.language.implicitConversions

object WalletPersistence {
  case class WalletEntry(id: Long, txIndx: TxIndex, amount: Int, state: Int, numConfirms: Int, created: DateTime, spendingTx: Option[TxId]) {
    val isUnspent = state == unspent
    val isSpent = state == spent
    val isKnown = state == recorded
    val balance = if(isUnspent) amount else 0

  }

  private lazy val tableName = s"wallet"

  private val id_str = "id"
  private val txid_str = "txid"
  private val txid_indx_str = "txid_indx"
  private val created_dt_str = "created_at"
  private val state_str = "tx_state"
  private val amount_str = "amount"
  private val confirms_str = "confirms"
  private val spending_txid_str = "spending_tx"

  private val recorded = 0
  private val unspent = 1
  private val spent = 2
}

class WalletPersistence(db:Db) extends Logging {

  import WalletPersistence._

  private val createTableSql =
    s"""CREATE TABLE IF NOT EXISTS $tableName
        |($id_str BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1),
        |$txid_str VARCHAR(64),
        |$spending_txid_str VARCHAR(64),
        |$txid_indx_str INT,
        |$state_str INT DEFAULT 0,
        |$confirms_str INT DEFAULT 0,
        |$amount_str INT DEFAULT 0,
        |$created_dt_str BIGINT,
        |PRIMARY KEY($txid_str, $txid_indx_str));
        |""".stripMargin

  db.executeSql(createTableSql)

  private val table = db.table(tableName)

  def inTransaction[T](f: => T): T = db.inTransaction[T](f)

  def addUnspent(txIndexStr: String, txIndexIndex: Int, amount: Int): WalletEntry = {
    add(txIndexStr, txIndexIndex, amount, unspent)
  }

  private def add(txIndexStr: String, txIndexIndex: Int, amount: Int, state: Int): WalletEntry = {
    table.insert(Map(txid_str -> txIndexStr, txid_indx_str -> txIndexIndex,
      amount_str -> amount, created_dt_str -> (new DateTime()).getMillis, state_str -> state))
  }

  private implicit def toWalletEntry(row: Row): WalletEntry = {
    val t = TxIndex(row(txid_str).toByteArray,row[Int](txid_indx_str))
    WalletEntry(row[Long](id_str), t, row[Int](amount_str), row[Int](state_str),row[Int](confirms_str),
      new DateTime(row[Long](created_dt_str)), Option(row[TxId](spending_txid_str)))
  }

  def spendingTx(entry: WalletEntry, txId: TxId) = {
    table.update(Map(id_str -> entry.id, spending_txid_str -> txId.toVarChar))
  }

  def addOrUpdate(txIndex: TxIndex, amount: Int): WalletEntry = {
    val idAsStr = txIndex.txId.toVarChar
    table.find(Where(s"$txid_str = ? AND $txid_indx_str = ?", idAsStr, txIndex.index)) match {
      case Some(row) => table.persist(Map(id_str -> row(id_str), amount_str -> amount, state_str -> recorded))
      case None => add(idAsStr, txIndex.index, amount, recorded)
    }


  }

  def filter(txId: TxId): Seq[WalletEntry] = {
    filterRows(txId) map (row =>  row : WalletEntry)
  }

  def find(txIndex: TxIndex): Option[WalletEntry] = {
    findRow(txIndex) map (row =>  row : WalletEntry)
  }

  private def get(txIndex: TxIndex)(f: Row => Unit) = db.inTransaction {
    findRow(txIndex) match {
      case None =>
        throw new IllegalArgumentException(s"${txIndex} does not exist!")
      case Some(row) => f(row)
    }
  }

  private def filterRows(txId: TxId): Seq[Row]= {
    val idAsStr = txId.toVarChar
    val sql = s"$txid_str = ? "
    table.filter(Where(sql, idAsStr))
  }

  private def findRow(txIndex: TxIndex): Option[Row]= {
    val idAsStr = txIndex.txId.toVarChar
    val sql = s"$txid_str = ? AND $txid_indx_str = ?"
    table.find(Where(sql, idAsStr, txIndex.index))
  }

  def findUnSpent: Seq[WalletEntry] = db.inTransaction {
    table.filter(Where(s"$state_str = ?", unspent)).map( row => row : WalletEntry )
  }

  def markSpent(txIndex: TxIndex): Unit = db.inTransaction {
    get(txIndex) { row => row[Int](state_str) match {
        case `recorded` => throw new IllegalArgumentException(s"$txIndex is only recorded, cannot be spent already.")
        case `unspent` => table.update(Map(id_str -> row(id_str), state_str -> spent))
        case `spent` => log.info(s"${txIndex} already is marked spent...")
      }
    }
  }

  /**
    *
    * @param txId
    * @param numConfirmsRequired
    * @return true if confirmed to num required, hence inputs marked spent and outputs unspent
    */
  def confirm(txId: TxId, numConfirmsRequired: Int): Int = db.inTransaction {

    filterRows(txId) foreach { row =>
      val we : WalletEntry = row
      table.update(Map(id_str -> we.id, txid_str -> txId.toVarChar, confirms_str -> (we.numConfirms + 1)))
      if(we.numConfirms >= numConfirmsRequired - 1) {
        table.filter(Where(s"$txid_str = ?", txId.toVarChar)) map { row =>
          table.update(Map(id_str -> row[Long](id_str), state_str -> unspent))
        }
        table.filter(Where(s"$spending_txid_str = ?", txId.toVarChar)) map { row =>
          table.update(Map(id_str -> row[Long](id_str), state_str -> spent))
        }
      }
    }
    filter(txId).head.numConfirms
  }

  def markUnspent(txIndex: TxIndex): Unit = db.inTransaction {
    get(txIndex) { row => row[Int](state_str) match {
      case `recorded` => table.update(Map(id_str -> row(id_str), state_str -> unspent))
      case `unspent` => log.info(s"${txIndex} already is marked unspent...")
      case `spent` => throw new IllegalArgumentException(s"$txIndex is already spent!!")
    }
    }
  }
}
