package sss.asado.block

import java.util.Date

import akka.actor.{Actor, ActorRef}
import sss.ancillary.Logging
import sss.asado.block.merkle.MerklePersist._
import sss.asado.block.merkle.{MerklePersist, MerkleTree}
import sss.asado.network.MessageRouter.Register
import sss.db.{Db, Where}

import scala.collection.mutable
import scala.util.Try

/**
  * Copyright Stepping Stone Software Ltd. 2016, all rights reserved. 
  * mcsherrylabs on 3/15/16.
  */
class BlockChainActor(configBase: String , msgCodes: Seq[Byte], messageRouter: ActorRef) extends Actor {

  msgCodes foreach (messageRouter ! Register(_))

  override def receive: Receive = ???
}


class BlockChain(implicit db: Db) extends Logging {

  import MerklePersist.MerklePersister
  import ledger._

  val blockTableNamePrefix = "block_"
  val merkleTableNamePrefix = "merkle_"

  private[block] lazy val blockHeaderTable = db.table("blockchain")

  def lastBlock: Try[BlockHeader] = {
    Try[BlockHeader] {
      blockHeaderTable.find(Where(" id > 0 ORDER BY height DESC LIMIT 1")) match {
        case None => throw new Error("No blocks found!")
        case Some(row) => BlockHeader(row)
      }
    }
  }

  def createBlock(height: Int) = Try {
    db.executeSql (s"CREATE TABLE IF NOT EXISTS $blockTableNamePrefix$height (id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), txid BLOB, indx INT, entry BLOB)")
  }


  def closeBlock: Try[BlockHeader] = {

    lastBlock map { prevHeader =>

      val height = prevHeader.height + 1
      val hashPrevBlock = prevHeader.hash
      lazy val blockTxsTable = db.table(s"$blockTableNamePrefix${height}")

      blockTxsTable inTransaction {
        val txs = blockTxsTable.map { row =>
          row[Array[Byte]]("entry").toSignedTx
        }.toSet

        val txIds: IndexedSeq[mutable.WrappedArray[Byte]] = txs.map(_.txId: mutable.WrappedArray[Byte]).toIndexedSeq
        val mt: MerkleTree[mutable.WrappedArray[Byte]] = MerkleTree(txIds)
        mt.persist(s"$merkleTableNamePrefix$height")

        val newBlock = new BlockHeader(height, txs.size, hashPrevBlock, mt.root.array, new Date())
        val newRow = blockHeaderTable.insert(newBlock.asMap)
        BlockHeader(newRow)
      }
      /*} match {
        case Failure(e) => {
          log.error(s"This block ($height)could not be saved, tx rolled back.", e)
          throw e
        }
        case Success(newBlock) => {
          log.info(s"Block $height successfully saved.")
          newBlock
        }*/
    }
  }

}