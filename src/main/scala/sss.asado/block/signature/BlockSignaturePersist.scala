package sss.asado.block.signature

import org.joda.time.DateTime
import scorex.crypto.signatures.SigningFunctions.{PublicKey, Signature}
import sss.db.{Db, Where}

/**
  * Created by alan on 4/1/16.
  */

trait BlockSignatures {
  def add(signature: Signature, signersPublicKey: PublicKey, nodeId: String)
  def indexOfBlockSignature(nodeId: String): Option[Int]
}

object BlockSignatures {

  private val id = "id"
  private val nodeId_str = "nodeId"
  private val created_dt_str = "created_dt"
  private val signature_str = "signature"
  private val public_key_str = "public_key"


  def apply(height: Long)(implicit db: Db): BlockSignatures = new BlockSignaturePersister(height)

  private class BlockSignaturePersister(height: Long)(implicit db: Db) extends BlockSignatures {

    private lazy val tableName = s"block_sigs_$height"

    private def createTableSql =
      s"""CREATE TABLE IF NOT EXISTS $tableName
          |($id INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1),
          |$nodeId_str VARCHAR(100),
          |$signature_str BLOB,
          |$public_key_str BLOB,
          |$created_dt_str BIGINT,
          |PRIMARY KEY($nodeId_str));
          |""".stripMargin

    private lazy val table = {
      db.executeSql(createTableSql)
      db.table(tableName)
    }

    override def add(signature: Signature, signersPublicKey: PublicKey, nodeId: String) = {
      table.insert(Map(nodeId_str -> nodeId,
        created_dt_str -> DateTime.now.getMillis,
        signature_str -> signature,
        public_key_str -> signersPublicKey
      ))
    }

    override def indexOfBlockSignature(nodeId: String): Option[Int] = {
      table.find(Where(s"$nodeId_str = ?", nodeId)) map( r => r[Int](id))
    }

  }
}
