package sss.asado.block

import block.{BlockTx, BlockTxId}
import com.twitter.util.SynchronizedLruMap
import ledger._
import sss.ancillary.Logging
import sss.asado.util.ByteArrayVarcharOps._
import sss.db.{Db, OrderAsc, Row, Where}

import scala.annotation.tailrec
import scala.util.{Failure, Success, Try}


object Block extends Logging {
  private val blockTableNamePrefix = "block_"
  private lazy val blockCache = new SynchronizedLruMap[Long, Block](10)
  private def makeTableName(height: Long) = s"$blockTableNamePrefix$height"
  def apply(height: Long)(implicit db:Db): Block = blockCache.getOrElseUpdate(height, new Block(height))

  private[block] def findSmallestMissing(candidates: Seq[Long]): Long = {

    @tailrec
    def hasNext(candis: Seq[Long], count: Long): Long = {
      candis match {
        case Seq() =>  count
        case head +: rest if(head == count + 1) => hasNext(rest, count + 1)
        case _ => count
      }
    }
    hasNext(candidates, 0)
  }
}

class Block(val height: Long)(implicit db:Db) extends Logging {

  import Block._

  val tableName = makeTableName(height)
  private val id = "id"
  private val txid = "txid"
  private val entry = "entry"

  db.executeSql (s"CREATE TABLE IF NOT EXISTS $tableName (id BIGINT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1), txid VARCHAR(64) NOT NULL, entry BLOB, confirm INT DEFAULT 0, PRIMARY KEY(id), UNIQUE(txid))")
  //db.executeSql (s"CREATE TABLE IF NOT EXISTS $tableName (txid VARCHAR(64) NOT NULL, entry BLOB, confirm INT DEFAULT 0, PRIMARY KEY (txid))")

  private val blockTxTable = db.table(tableName)

  private[block] def truncate: Unit = db.executeSql(s"TRUNCATE TABLE $tableName")

  def entries: Seq[SignedTx] = {
    blockTxTable.map ({ row =>
      row[Array[Byte]]("entry").toSignedTx
    }, OrderAsc(id))
  }

  private def toBlockTx(r: Row): BlockTx = BlockTx(r[Long](id), r[Array[Byte]](entry).toSignedTx)

  def page(index: Long, pageSize: Int): Seq[Array[Byte]] = {
    blockTxTable.page(index, pageSize, Seq(OrderAsc(id))) map(r => r[Array[Byte]](entry))
  }

  def maxMonotonicIndex: Long = {
    val allIds = blockTxTable.map(r => r[Long](id), OrderAsc(id))
    findSmallestMissing(allIds)
  }

  def apply(k: TxId): BlockTx = get(k).get

  def count = blockTxTable.count

  def inTransaction[T](f: => T): T = blockTxTable.inTransaction[T](f)

  def get(id: TxId): Option[BlockTx] = blockTxTable.find(Where(s"$txid = ?", id.toVarChar)).map(toBlockTx)


  def delete(id: TxId): Boolean = blockTxTable.delete(Where(s"$txid = ?", id.toVarChar)) == 1

  def write(index: Long, k: TxId, le: SignedTx): Long = {
    val bs = le.toBytes
    val hexStr = k.toVarChar
    val row = blockTxTable.insert(Map(id -> index, txid -> hexStr, entry -> bs))
    row(id)
  }

  def write(k: TxId, le: SignedTx): Long = {
    val bs = le.toBytes
    val hexStr = k.toVarChar
    val row = blockTxTable.persist(Map(txid -> hexStr, entry -> bs))
    row(id)
  }

  def getUnconfirmed(requiredConfirms: Int): Seq[(Int, BlockTx)] = {
    val all = blockTxTable.filter(Where("confirm < ?", requiredConfirms)) map (row => (row[Int]("confirm"), toBlockTx(row)))
    log.info("Print ALL with 0")
    all.foreach {case (conf: Int, btx: BlockTx) => log.info(s"Not enough confirms:$conf ${btx.toString}")}
    all
  }

  def confirm(blockTxId: BlockTxId): Unit = {
    Try {
      val hex = blockTxId.txId.toVarChar
      val rowsUpdated = blockTxTable.update("confirm = confirm + 1", s"txid = '$hex'")
      require(rowsUpdated == 1, s"Must update 1 row, by confirming the tx, not $rowsUpdated rows")

    } match {
      case Failure(e) => log.error(s"FAILED to add confirmation!", e)
      case Success(r) => log.info(s"Tx confirmed. $r")
    }
  }
}
