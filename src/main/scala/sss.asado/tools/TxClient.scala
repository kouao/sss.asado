package sss.asado.tools


import akka.actor.{Actor, ActorLogging, ActorRef, ActorSystem, Props}
import akka.agent.Agent
import com.google.common.primitives.Longs
import com.typesafe.config.Config
import ledger.{SignedTx, StandardTx, TxId, TxIndex, TxInput, TxOutput}
import org.joda.time.DateTime
import sss.ancillary.Logging
import sss.asado.account.{ClientKey, PrivateKeyAccount}
import sss.asado.contract.{PrivateKeySig, SinglePrivateKey}
import sss.asado.network.MessageRouter.Register
import sss.asado.network.NetworkController.{BindControllerSettings, ConnectTo, SendToNetwork}
import sss.asado.network._
import sss.asado.util.ByteArrayVarcharOps._
import sss.asado.{BaseClient, MessageKeys}
import sss.db.{Db, Row, Where}

import scala.concurrent.ExecutionContext.Implicits.global
import scala.concurrent.duration._
import scala.language.postfixOps
import scala.util.{Failure, Success, Try}

/**
  * Copyright Stepping Stone Software Ltd. 2016, all rights reserved. 
  * mcsherrylabs on 3/9/16.
  */

case class WalletEntry(id: Int, txIndx: TxIndex, amount: Int, state: Int, numConfirms: Int, created: DateTime, spendingTx: Option[TxId]) {
  import ClientWallet._
  val isUnspent = state == unspent
  val isSpent = state == spent
  val isKnown = state == recorded
}

object ClientWallet {
  private lazy val tableName = s"wallet"

  private val id_str = "id"
  private val txid_str = "txid"
  private val txid_indx_str = "txid_indx"
  private val created_dt_str = "created_at"
  private val state_str = "tx_state"
  private val amount_str = "amount"
  private val confirms_str = "confirms"
  private val spending_txid_str = "spending_tx"


  val recorded = 0
  val unspent = 1
  val spent = 2
}

class ClientWallet()(implicit db:Db) extends Logging {

  import ClientWallet._
  private val createTableSql =
    s"""CREATE TABLE IF NOT EXISTS $tableName
        |($id_str INT GENERATED BY DEFAULT AS IDENTITY (START WITH 1, INCREMENT BY 1),
        |$txid_str VARCHAR(64),
        |$spending_txid_str VARCHAR(64),
        |$txid_indx_str INT,
        |$state_str INT DEFAULT 0,
        |$confirms_str INT DEFAULT 0,
        |$amount_str INT DEFAULT 0,
        |$created_dt_str BIGINT,
        |PRIMARY KEY($txid_str, txid_indx_str));
        |""".stripMargin

  db.executeSql(createTableSql)

  private val table = db.$tableName

  def add(txIndexStr: String, txIndexIndex: Int, amount: Int): WalletEntry = {
    table.insert(Map(txid_str -> txIndexStr, txid_indx_str -> txIndexIndex,
      amount_str -> amount, created_dt_str -> (new DateTime()).getMillis))
  }

  private implicit def toWalletEntry(row: Row): WalletEntry = {
    val t = TxIndex(row(txid_str).toByteArray,row[Int](txid_indx_str))
    WalletEntry(row[Int](id_str), t, row[Int](amount_str), row[Int](state_str),row[Int](confirms_str),
      new DateTime(row[Long](created_dt_str)), row[Option[TxId]](spending_txid_str))
  }

  def spendingTx(entry: WalletEntry, txId: TxId) = {
    table.update(Map(id_str -> entry.id, spending_txid_str -> txId.toVarChar))
  }

  def add(txIndex: TxIndex, amount: Int): WalletEntry = {
    val idAsStr = txIndex.txId.toVarChar
    add(idAsStr, txIndex.index, amount)
  }

  def filter(txId: TxId): Seq[WalletEntry] = {
    filterRows(txId) map (row =>  row : WalletEntry)
  }

  def find(txIndex: TxIndex): Option[WalletEntry] = {
    findRow(txIndex) map (row =>  row : WalletEntry)
  }

  def get(txIndex: TxIndex)(f: Row => ()) = db.inTransaction {
    findRow(txIndex) match {
      case None =>
        throw new IllegalArgumentException(s"${txIndex} does not exist!")
      case Some(row) => f(row)
    }
  }

  private def filterRows(txId: TxId): Seq[Row]= {
    val idAsStr = txId.toVarChar
    val sql = s"$txid_str = ? "
    table.filter(Where(sql, idAsStr))
  }

  private def findRow(txIndex: TxIndex): Option[Row]= {
    val idAsStr = txIndex.txId.toVarChar
    val sql = s"$txid_str = ? AND $txid_indx_str = ?"
    table.find(Where(sql, idAsStr, txIndex.index))
  }

  def findUnSpent: Seq[WalletEntry] = db.inTransaction {
    table.filter(Where(s"$state_str = ?", unspent)).map( row => row : WalletEntry )
  }

  def markSpent(txIndex: TxIndex): Unit = db.inTransaction {
    get(txIndex) { row => row[Int](state_str) match {
        case `recorded` => throw new IllegalArgumentException(s"$txIndex is only recored, cannot be spent already.")
        case `unspent` => table.update(Map(id_str -> row(id_str), state_str -> spent))
        case `spent` => log.info(s"${txIndex} already is marked spent...")
      }
    }
  }

  /**
    *
    * @param txId
    * @param numConfirmsRequired
    * @return true if confirmed to num required, hence inputs marked spent and outputs unspent
    */
  def confirm(txId: TxId, numConfirmsRequired: Int): Int = db.inTransaction {

    filterRows(txId) foreach { row =>
      val we : WalletEntry = row
      table.update(Map(txid_str -> txId.toVarChar, confirms_str -> (we.numConfirms + 1)))
      if(we.numConfirms >= numConfirmsRequired - 1) {
        table.update(Map(txid_str -> txId.toVarChar, state_str -> unspent))
        table.update(Map(spending_txid_str -> txId.toVarChar, state_str -> spent))

      }
    }
    filter(txId).head.numConfirms
  }

  def markUnspent(txIndex: TxIndex): Unit = db.inTransaction {
    get(txIndex) { row => row[Int](state_str) match {
        case `recorded` => table.update(Map(id_str -> row(id_str), state_str -> unspent))
        case `unspent` => log.info(s"${txIndex} already is marked unspent...")
        case `spent` => throw new IllegalArgumentException(s"$txIndex is already spent!!")
      }
    }
  }
}

object TxClient extends BaseClient {



  override protected def run(settings: BindControllerSettings,
                             actorSystem: ActorSystem,
                             peerList: Set[NodeId],
                             connectedPeers: Agent[Set[Connection]],
                             messageRouter: ActorRef,
                             ncRef: ActorRef,
                             nodeConfig: Config,
                             args: Array[String]
                            ): Unit = {

    val wallet = new ClientWallet()

    val pka = args match {
      case Array(clientName) => ClientKey(clientName)
      case Array(clientName, unspentTxIdVarChar, unspentIndex, amount) =>
        val added = wallet.add(unspentTxIdVarChar, unspentIndex.toInt, amount.toInt)
        wallet.markUnspent(added.txIndx)
        ClientKey(clientName)
    }


    val ref = actorSystem.actorOf(Props(classOf[WalletActor], args,peerList: Set[NodeId],
      connectedPeers: Agent[Set[Connection]], messageRouter, ncRef))

    while (connectedPeers().size == 0) {
      println("Waiting for connection...")
      Thread.sleep(1111)
    }

    ref ! CheckConnection
    peerList.foreach(e => println(s"Connected $e"))

  }
}
case object CheckConnection
case class NewTx(stx: SignedTx)

class WalletActor(minConfirms: Int, pka: PrivateKeyAccount, wallet: ClientWallet, db: Db, peerList: Set[NodeId],
                    connectedPeers: Agent[Set[Connection]], messageRouter: ActorRef, ncRef: ActorRef) extends Actor with ActorLogging {

  import block._


  messageRouter ! Register(MessageKeys.SignedTxAck)
  messageRouter ! Register(MessageKeys.SignedTxNack)
  messageRouter ! Register(MessageKeys.AckConfirmTx)
  messageRouter ! Register(MessageKeys.NackConfirmTx)

  def createTx(txIndex: TxIndex, amunt: Int): SignedTx = {
    val txOutput = TxOutput(amunt, SinglePrivateKey(pka.publicKey))
    val txInput = TxInput(txIndex, amunt, PrivateKeySig)
    val tx = StandardTx(Seq(txInput), Seq(txOutput))
    val sig = tx.sign(pka)
    SignedTx(tx, Seq(sig))
  }

  override def receive: Receive = {
    case NetworkMessage(MessageKeys.SignedTxAck, bytes) => {
      val blcok = Longs.fromByteArray(bytes)
      println(s"Tx in $blcok")
    }

    case NewTx(stx) =>
      var continueFlag = true
      val txId = stx.tx.txId
      Try(db.inTransaction {
        stx.tx.ins foreach { in =>
          wallet.find(in.txIndex) match {
            case Some(entry) if !entry.isUnspent =>
              log.error(s"Cannot continue with this tx, one of the tx inputs is not unspent ${in.txIndex}")
              continueFlag = false
            case None =>
              log.error(s"Cannot continue with this tx, one of the tx inputs is unknown ${in.txIndex}")
              continueFlag = false
            case Some(entry) => wallet.spendingTx(entry, txId)
          }
        }
        if (continueFlag) {
          log.info(s"All the inputs were ok ")
          var index = 0
          stx.tx.outs foreach { out =>
            wallet.add(TxIndex(txId, index), out.amount)
            index += 1
          }
          log.info(s"All the outputs were recored, sending now. ")
          ncRef ! SendToNetwork(NetworkMessage(MessageKeys.SignedTx, stx.toBytes))
        }
      }) match {
        case Success(_) =>
        case Failure(e) => log.error(e, "Failed to process new tx ")
      }


    case CheckConnection =>
      if (connectedPeers().size < peerList.size) peerList foreach (ncRef ! ConnectTo(_))
      context.system.scheduler.scheduleOnce(5 seconds, self, CheckConnection)

    case NetworkMessage(MessageKeys.SignedTxNack, bytes) =>
      log.info(s"We got a nack for our tx. " + new String(bytes))


    case NetworkMessage(MessageKeys.AckConfirmTx, bytes) =>
      val confirmed = bytes.toBlockChainIdTx

      val numconfirms = wallet.confirm(confirmed.blockTxId.txId, minConfirms )
      if(numconfirms >= minConfirms)  log.info(s"Tx ${confirmed.blockTxId} confirmed.")
      else log.info(s"Tx ${confirmed.blockTxId} confirmed.")

    case x => log.info(s"No idea $x")
  }
}

